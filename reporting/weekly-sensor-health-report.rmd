---
title: "Weekly Air Sensor Health Report"
author: "Earthwatch Institute"
date: "`r format(Sys.time(), '%d %B, %Y')`"
output: 
  html_document:
    toc: true
    toc_float: true
    df_print: paged
params:
  program: "All"
  
---

```{r setup, include=FALSE}
library(here)
library(dplyr)
library(ggplot2)
devtools::load_all("C://Users/iozeroff/Data-Science/R-Projects/AirSensor")
devtools::load_all()
library(purrr)
library(formattable)

knitr::opts_knit$set(root.dir = here::here())

```

```{r ingestion, include=FALSE}
# Define problematic cutoffs for looking more closely at site sensors.
# TODO: Add Pct_Cutoff and Rsquared Cutoff as params to the rmd?
MazamaSpatialUtils::setSpatialDataDir("data/spatial")

pat_list <- load_pat_list()

if (params$program != "All") {
  sensor_catalog <- load_SensorCatalog() %>%
    filter(site != "Undeployed", Program == params$program)
  pat_list <- pat_list[sensor_catalog$label] 
}

```

# Ingestion Status

Below are the sensors that failed to ingest correctly.

```{r Loading Issues, echo=FALSE, warning=FALSE}

issues_list <- list()

# Checks elements of pat_list whether they are or are not pats.
pat_test <- purrr::map_lgl(.x = pat_list, .f = pat_isPat)

if ( any(!pat_test) ){
  
  # Grab labels of pats that failed to load.
  error_list <- pat_list[!pat_test]
  # Add to issues list.
  issues_list <- error_list
  
  # Filters pat_list according to pat_test
  pat_list <- pat_list[pat_test]
  
}  

# Checks if pats contains data after week filter.
empty_test <- purrr::map_lgl(pat_list, pat_isEmpty)    

if ( any(empty_test) ) {
  
  # Get labels of empty pats.
  empty_labs <- names(pat_list_wk[empty_test])
  
  empty_list <- list()
  
  for (i in 1:length(empty_labs)) {
    empty_lab <- empty_labs[i]
    empty_list[empty_lab] <- "Empty"
  }
  
  issues_list <- c(issues_list, empty_list)
  
  # Filters out empty data pats.
  pat_list_wk <- pat_list_wk[!empty_data_test] 

}

# Making filter function safe.
safe_pat_filterDate <- purrr::safely(.f = pat_filterDate)

# Safely filters pat_list for past week.
filter_results <- pat_list %>% 
  purrr::map(safe_pat_filterDate, days = 7) %>% 
  purrr::transpose()
  
# Getting pats from results
pat_list_wk <- filter_results$result
# Getting errors.
filter_errors <- filter_results$error %>%
  purrr::compact() %>% 
  purrr::map(.f = function(x) x$message)
# Adding to error list.
issues_list <- c(issues_list, filter_errors)
  

if ( length(issues_list) >= 1 ) {
  
  
  # Creating dataframe of sensors that didn't load properly and their error messages.
  pat_errors <- reshape::melt(issues_list) %>%
    select(`Sensor Label` = 2, Error = 1) %>%
    # Cleaning Error Message.
    mutate(Error = stringr::str_replace(.data$Error, pattern = "^.*, :", replacement = "Error: ")) %>%
    mutate(
      Error = case_when(
       stringr::str_detect(Error, "pat does not contain requested date range") ~ "Error: sensor has not uploaded data in the past seven days.",
       stringr::str_detect(Error, "^Empty$") ~ "Error: Sensor detected by PurpleAir.com but no data loaded.",
       # TODO Add more case interpretation.
       TRUE ~ paste("Unexpected ", Error)
      )
    )

  pat_errors %>% 
    knitr::kable(align = c("l", "r"))

} else {
  print("No errors loading sensors.")
}

if (length(pat_list) == 0) {
  knitr::knit_exit()
}

```

```{r Empty PAT testing, echo=FALSE}

empty_test <- purrr::map_lgl(.x = pat_list, .f = function(x) nrow(pat_extractData(x)) > 0)

if(sum(empty_test) < length(empty_test)) {
  print("The following Purple Air Time Series loaded, but are empty.")
  empty_pats <- names(pat_list)[!empty_test]
  print(empty_pats)
  print("They are not evaluated in the following report.")
  pat_list <- pat_list[empty_test]
}

```


# Sensor Function Evaluation {.tabset}

Below you will find graphs that you can evaluate for possible hardware or reporting issues.


## Sensor Weekly Statistics
```{r Weekly SoH Stats, echo=FALSE}

# Define the functions we want pat_dailySoH to run on our sensors.
desired_functions = c("PurpleAirSoH_dailyPctReporting",
                      "PurpleAirSoH_dailyPctValid",
                      "PurpleAirSoH_dailyABFit")

# Generates daily State of Health values for every pat in pat_list.
pat_list_weekly_SoH <- map(pat_list, AirSensor::pat_dailySoH,
                         SoH_functions = desired_functions) %>% 
  bind_rows(.id = "sensor") %>% # Binds all into single df.
  select(-c("pm25_A_pm25_B_slope", "pm25_A_pm25_B_intercept")) %>% # Adds site variable from catalog.
  group_by(sensor) %>% 
  summarize_if(is.numeric, mean)

# Creates hourly aggregated datasets from each sensor. 
# Getting error in `[[<-.data.frame`(`*tmp*`, outlierFlagName, value = FALSE) : replacement has 1 row, data has 0
aggregated <- purrr::map(pat_list, .f = pat_aggregate)

# Shows how many of the hours have at least 20 observations for A and for B. 
sensor_weekly_SoH <- aggregated %>% 
  bind_rows(.id = "sensor") %>% 
  mutate(usable_A = ifelse(pm25_A_count >= 20, TRUE, FALSE),
         usable_B = ifelse(pm25_B_count >= 20, TRUE, FALSE)) %>% 
  group_by(sensor) %>% 
  summarize(pct_usable_hours_A = sum(usable_A)/ 168,
            pct_usable_hours_B = sum(usable_B)/ 168) %>% 
  left_join(pat_list_weekly_SoH, by = "sensor") %>% 
  left_join(select(sensor_catalog, site, label), by = c("sensor" = "label")) %>%
  arrange(site, sensor)
```


```{r SOH Statistics Table, echo=FALSE}

# Defines Columns to include in table.
table_cols <- c(
  "sensor", 
  "pct_usable_hours_A",
  "pct_usable_hours_B",
  "pm25_A_pctReporting",
  "pm25_B_pctReporting",
  "pm25_A_pctValid",
  "pm25_B_pctValid",
  "pm25_A_pm25_B_rsquared"
)

# Defines cleaner columns names for table.
table_colnames <-  c(
  "Sensor",
  "Percentage Usable A Hours",
  "Percentage Usable B Hours",
  "PM25 A Pct. Reporting",
  "PM25 B Pct. Reporting",
  "PM25 A Pct. Valid",
  "PM25 B Pct. Valid",
  "Channel AB R2"
)

sensor_weekly_SoH %>% 
  select(all_of(table_cols)) %>% 
  arrange(pct_usable_hours_A, pct_usable_hours_B,
          pm25_A_pctReporting, pm25_B_pctReporting,
          pm25_A_pm25_B_rsquared,
          pm25_A_pctValid, pm25_B_pctValid) %>% 
  mutate_at(vars(-sensor), .funs = function(x) formattable::color_tile("#c1531b", "#62a70f",
                                                                       na.rm = TRUE)(x)) %>%
  formattable::formattable(booktabs = T, digits = 3, col.names = table_colnames)

```

## Table Key

Below are summary statistics for every site. They are the averaged over every sensor we were able to ingest (see above for reference). Below see a short description of each statistic:
```{r Table Key, echo = FALSE}
col_descriptions <- c(
  "The user-created sensor label.",
  "The percentage of hours with at least 20 PM measurements by Channel A out of a possible 168 (the number of hours in a week).",
  "The percentage of hours with at least 20 PM measurements by Channel B out of a possible 168 (the number of hours in a week).",
  "The percentage of daily Particulate Matter 2.5 readings collected by Channel A out of the total possible daily opportunities for data collection. (Sensors channels generate readings every 120 seconds.)",
  "The percentage of daily Particulate Matter 2.5 readings collected by Channel B out of the total possible daily opportunities for data collection. (Sensors channels generate readings every 120 seconds.)",
  "The percent of Channel A PM2.5 readings that are within the sensor's detection range (0 to 1000 ug/m3).",
  "The percent of Channel B PM2.5 readings that are within the sensor's detection range (0 to 1000 ug/m3).",
  "Essentially the correlation between channels A and B. Ranges from 0 being no predictable relationship between A and B and 1 being perfect synchronicity between the channels."
  )

table_key <- data.frame(
  table_colnames,
  col_descriptions
)

table_key %>% 
  knitr::kable(format = "html") %>% 
  kableExtra::kable_styling(bootstrap_options = "bordered")

  
```


## State of Health Index Plots

The below plots use the MazamaScience AirSensor Sensor Health index to categorize the state of the sensor's health. This index is based on the A B rsquared (described above), to rank sensor reporting days as Good, Fair, or Poor. Red dots are channel A PM2.5 measurements. Blue dots are channel B PM2.5 measurements. The color bar underneath the points in the plot corresponds to the rated health index of the sensor for the corresponding day.

```{r Weekly SoH Plots, echo=FALSE}

for (i in 1:length(pat_list)) {
    pat <- pat_list[[i]]
    plot <- pat_dailySoHIndexPlot(pat)
    print(plot)
}
```