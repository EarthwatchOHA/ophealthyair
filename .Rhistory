map(pat_list, AirSensor::pat_dailySoH,
SoH_functions = desired_functions)
# Define the functions we want pat_dailySoH to run on our sensors.
desired_functions = c("PurpleAirSoH_dailyPctReporting",
"PurpleAirSoH_dailyPctValid",
"PurpleAirSoH_dailyABFit")
?pat_dailySoH
library(here)
library(dplyr)
library(ggplot2)
library(AirSensor)
devtools::load_all()
library(purrr)
library(formattable)
knitr::opts_knit$set(root.dir = here::here())
# Define problematic cutoffs for looking more closely at site sensors.
MazamaSpatialUtils::setSpatialDataDir("data/spatial")
pat_list <- load_pat_list()
if (params$program != "All") {
sensor_catalog <- load_SensorCatalog() %>%
filter(site != "Undeployed", Program == params$program)
pat_list <- pat_list[sensor_catalog$label]
}
issues_list <- list()
# Checks elements of pat_list whether they are or are not pats.
pat_test <- purrr::map_lgl(.x = pat_list, .f = pat_isPat)
if ( any(!pat_test) ){
# Grab labels of pats that failed to load.
error_list <- pat_list[!pat_test]
# Add to issues list.
issues_list <- error_list
# Filters pat_list according to pat_test
pat_list <- pat_list[pat_test]
}
# Making filter function safe.
safe_pat_filterDate <- purrr::safely(.f = pat_filterDate)
# Safely filters pat_list for past week.
filter_results <- pat_list %>%
purrr::map(safe_pat_filterDate, days = 7) %>%
purrr::transpose()
# Getting pats from results
pat_list_wk <- filter_results$result
# Checks if pats contains data after week filter.
empty_test <- purrr::map_lgl(pat_list, pat_isEmpty)
if ( any(empty_test) ) {
# Get labels of empty pats.
empty_labs <- names(pat_list_wk[empty_test])
empty_list <- list()
for (i in 1:length(empty_labs)) {
empty_lab <- empty_labs[i]
empty_list[empty_lab] <- "Empty"
}
issues_list <- c(issues_list, empty_list)
# Filters out empty data pats.
pat_list_wk <- pat_list_wk[!empty_data_test]
}
# Getting errors.
filter_errors <- filter_results$error %>%
purrr::compact() %>%
purrr::map(.f = function(x) x$message)
# Adding to error list.
issues_list <- c(issues_list, filter_errors)
if ( length(issues_list) >= 1 ) {
# Creating dataframe of sensors that didn't load properly and their error messages.
pat_errors <- reshape::melt(issues_list) %>%
select(`Sensor Label` = 2, Error = 1) %>%
# Cleaning Error Message.
mutate(Error = stringr::str_replace(.data$Error,
pattern = "^.*, :",
replacement = "Error: ")) %>%
mutate(
Error = case_when(
stringr::str_detect(Error,
"pat does not contain requested date range") ~ "Error: sensor has not uploaded data in the past seven days.",
stringr::str_detect(Error, "^Empty$") ~ "Error: Sensor detected by PurpleAir.com but no data loaded.",
# TODO Add more case interpretation.
TRUE ~ paste("Unexpected ", Error)
)
)
pat_errors %>%
knitr::kable(align = c("l", "r"))
} else {
print("No errors loading sensors.")
}
if (length(pat_list) == 0) {
knitr::knit_exit()
}
empty_test <- purrr::map_lgl(.x = pat_list, .f = function(x) nrow(pat_extractData(x)) > 0)
if(sum(empty_test) < length(empty_test)) {
print("The following Purple Air Time Series loaded, but are empty.")
empty_pats <- names(pat_list)[!empty_test]
print(empty_pats)
print("They are not evaluated in the following report.")
pat_list <- pat_list[empty_test]
}
# Define the functions we want pat_dailySoH to run on our sensors.
desired_functions = c("PurpleAirSoH_dailyPctReporting",
"PurpleAirSoH_dailyPctValid",
"PurpleAirSoH_dailyABFit")
map(pat_list, AirSensor::pat_dailySoH,
SoH_functions = desired_functions)
# Define the functions we want pat_dailySoH to run on our sensors.
SoH_functions = c("PurpleAirSoH_dailyPctReporting",
"PurpleAirSoH_dailyPctValid",
"PurpleAirSoH_dailyABFit")
# Define the functions we want pat_dailySoH to run on our sensors.
SoH_functions = c("PurpleAirSoH_dailyPctReporting",
# "PurpleAirSoH_dailyPctValid",
"PurpleAirSoH_dailyABFit")
# Define the functions we want pat_dailySoH to run on our sensors.
SoH_functions = c("PurpleAirSoH_dailyPctReporting",
"PurpleAirSoH_dailyPctValid",
"PurpleAirSoH_dailyABFit")
purrr::map(pat_list, AirSensor::pat_dailySoH,
SoH_functions = SoH_functions) %>%
purrr::map(pat_list, AirSensor::pat_dailySoH,
SoH_functions = SoH_functions)
SoH_functions = c("PurpleAirSoH_dailyPctReporting")
purrr::map(pat_list, AirSensor::pat_dailySoH,
SoH_functions = SoH_functions)
SoH_functions <- c("PurpleAirSoH_dailyPctReporting",
"PurpleAirSoH_dailyPctValid")
purrr::map(pat_list, AirSensor::pat_dailySoH,
SoH_functions = SoH_functions)
# Define the functions we want pat_dailySoH to run on our sensors.
SoH_functions <- c("PurpleAirSoH_dailyPctReporting",
# "PurpleAirSoH_dailyPctValid"),
"PurpleAirSoH_dailyABFit")
purrr::map(pat_list, AirSensor::pat_dailySoH,
SoH_functions = SoH_functions)
remove.packages("AirSensor")
install.packages("AirSensor")
install.packages("AirSensor")
library(AirSensor)
devtools::install_github("MazamaScience/AirSensor")
library(here)
library(dplyr)
library(ggplot2)
library(AirSensor)
devtools::load_all()
library(purrr)
library(formattable)
knitr::opts_knit$set(root.dir = here::here())
# Define the functions we want pat_dailySoH to run on our sensors.
SoH_functions <- c("PurpleAirSoH_dailyPctReporting",
# "PurpleAirSoH_dailyPctValid"),
"PurpleAirSoH_dailyABFit")
purrr::map(pat_list, AirSensor::pat_dailySoH,
SoH_functions = SoH_functions)
remove.packages("AirSensor")
devtools::install_github("MazamaSciece/AirSensor", ref = "v0.7.0")
devtools::install_github("MazamaScience/AirSensor", ref = "v0.7.0")
devtools::install_github("MazamaScience/AirSensor", ref = "AirSensor 0.7.0")
devtools::install_github("MazamaScience/AirSensor", ref = "0.7.0")
devtools::install_github("MazamaScience/AirSensor", ref = "0.7.0")
library(here)
library(dplyr)
library(ggplot2)
library(AirSensor)
devtools::load_all()
library(purrr)
library(formattable)
knitr::opts_knit$set(root.dir = here::here())
# Define problematic cutoffs for looking more closely at site sensors.
MazamaSpatialUtils::setSpatialDataDir("data/spatial")
pat_list <- load_pat_list()
if (params$program != "All") {
sensor_catalog <- load_SensorCatalog() %>%
filter(site != "Undeployed", Program == params$program)
pat_list <- pat_list[sensor_catalog$label]
}
issues_list <- list()
# Checks elements of pat_list whether they are or are not pats.
pat_test <- purrr::map_lgl(.x = pat_list, .f = pat_isPat)
if ( any(!pat_test) ){
# Grab labels of pats that failed to load.
error_list <- pat_list[!pat_test]
# Add to issues list.
issues_list <- error_list
# Filters pat_list according to pat_test
pat_list <- pat_list[pat_test]
}
# Making filter function safe.
safe_pat_filterDate <- purrr::safely(.f = pat_filterDate)
# Safely filters pat_list for past week.
filter_results <- pat_list %>%
purrr::map(safe_pat_filterDate, days = 7) %>%
purrr::transpose()
# Getting pats from results
pat_list_wk <- filter_results$result
# Checks if pats contains data after week filter.
empty_test <- purrr::map_lgl(pat_list, pat_isEmpty)
if ( any(empty_test) ) {
# Get labels of empty pats.
empty_labs <- names(pat_list_wk[empty_test])
empty_list <- list()
for (i in 1:length(empty_labs)) {
empty_lab <- empty_labs[i]
empty_list[empty_lab] <- "Empty"
}
issues_list <- c(issues_list, empty_list)
# Filters out empty data pats.
pat_list_wk <- pat_list_wk[!empty_data_test]
}
# Getting errors.
filter_errors <- filter_results$error %>%
purrr::compact() %>%
purrr::map(.f = function(x) x$message)
# Adding to error list.
issues_list <- c(issues_list, filter_errors)
if ( length(issues_list) >= 1 ) {
# Creating dataframe of sensors that didn't load properly and their error messages.
pat_errors <- reshape::melt(issues_list) %>%
select(`Sensor Label` = 2, Error = 1) %>%
# Cleaning Error Message.
mutate(Error = stringr::str_replace(.data$Error,
pattern = "^.*, :",
replacement = "Error: ")) %>%
mutate(
Error = case_when(
stringr::str_detect(Error,
"pat does not contain requested date range") ~ "Error: sensor has not uploaded data in the past seven days.",
stringr::str_detect(Error, "^Empty$") ~ "Error: Sensor detected by PurpleAir.com but no data loaded.",
# TODO Add more case interpretation.
TRUE ~ paste("Unexpected ", Error)
)
)
pat_errors %>%
knitr::kable(align = c("l", "r"))
} else {
print("No errors loading sensors.")
}
if (length(pat_list) == 0) {
knitr::knit_exit()
}
empty_test <- purrr::map_lgl(.x = pat_list, .f = function(x) nrow(pat_extractData(x)) > 0)
if(sum(empty_test) < length(empty_test)) {
print("The following Purple Air Time Series loaded, but are empty.")
empty_pats <- names(pat_list)[!empty_test]
print(empty_pats)
print("They are not evaluated in the following report.")
pat_list <- pat_list[empty_test]
}
# Define the functions we want pat_dailySoH to run on our sensors.
SoH_functions <- c("PurpleAirSoH_dailyPctReporting",
"PurpleAirSoH_dailyPctValid",
"PurpleAirSoH_dailyABFit")
# Generates daily State of Health values for every pat in pat_list.
pat_list_weekly_SoH <- purrr::map(pat_list, AirSensor::pat_dailySoH,
SoH_functions = SoH_functions) %>%
bind_rows(.id = "sensor") %>% # Binds all into single df.
select(-c("pm25_A_pm25_B_slope", "pm25_A_pm25_B_intercept")) %>% # Adds site variable from catalog.
group_by(sensor) %>%
summarize_if(is.numeric, mean)
purrr::map(pat_list, AirSensor::pat_dailySoH,
SoH_functions = SoH_functions)
View(pat_dailySoH)
View(PurpleAirSoH_dailyPctValid)
SoH_functions <- c("PurpleAirSoH_dailyPctReporting")
purrr::map(pat_list, AirSensor::pat_dailySoH,
SoH_functions = SoH_functions) %>% View()
remove.packages("AirSensor")
devtools::install_github("MazamaScience/AirSensor", ref = "0.5.18")
devtools::install_github("MazamaScience/AirSensor", ref = "0.5.18")
library(here)
library(dplyr)
library(ggplot2)
library(AirSensor)
devtools::load_all()
library(purrr)
library(formattable)
knitr::opts_knit$set(root.dir = here::here())
# Define problematic cutoffs for looking more closely at site sensors.
MazamaSpatialUtils::setSpatialDataDir("data/spatial")
pat_list <- load_pat_list()
if (params$program != "All") {
sensor_catalog <- load_SensorCatalog() %>%
filter(site != "Undeployed", Program == params$program)
pat_list <- pat_list[sensor_catalog$label]
}
issues_list <- list()
# Checks elements of pat_list whether they are or are not pats.
pat_test <- purrr::map_lgl(.x = pat_list, .f = pat_isPat)
if ( any(!pat_test) ){
# Grab labels of pats that failed to load.
error_list <- pat_list[!pat_test]
# Add to issues list.
issues_list <- error_list
# Filters pat_list according to pat_test
pat_list <- pat_list[pat_test]
}
# Making filter function safe.
safe_pat_filterDate <- purrr::safely(.f = pat_filterDate)
# Safely filters pat_list for past week.
filter_results <- pat_list %>%
purrr::map(safe_pat_filterDate, days = 7) %>%
purrr::transpose()
# Getting pats from results
pat_list_wk <- filter_results$result
# Checks if pats contains data after week filter.
empty_test <- purrr::map_lgl(pat_list, pat_isEmpty)
if ( any(empty_test) ) {
# Get labels of empty pats.
empty_labs <- names(pat_list_wk[empty_test])
empty_list <- list()
for (i in 1:length(empty_labs)) {
empty_lab <- empty_labs[i]
empty_list[empty_lab] <- "Empty"
}
issues_list <- c(issues_list, empty_list)
# Filters out empty data pats.
pat_list_wk <- pat_list_wk[!empty_data_test]
}
# Getting errors.
filter_errors <- filter_results$error %>%
purrr::compact() %>%
purrr::map(.f = function(x) x$message)
# Adding to error list.
issues_list <- c(issues_list, filter_errors)
if ( length(issues_list) >= 1 ) {
# Creating dataframe of sensors that didn't load properly and their error messages.
pat_errors <- reshape::melt(issues_list) %>%
select(`Sensor Label` = 2, Error = 1) %>%
# Cleaning Error Message.
mutate(Error = stringr::str_replace(.data$Error,
pattern = "^.*, :",
replacement = "Error: ")) %>%
mutate(
Error = case_when(
stringr::str_detect(Error,
"pat does not contain requested date range") ~ "Error: sensor has not uploaded data in the past seven days.",
stringr::str_detect(Error, "^Empty$") ~ "Error: Sensor detected by PurpleAir.com but no data loaded.",
# TODO Add more case interpretation.
TRUE ~ paste("Unexpected ", Error)
)
)
pat_errors %>%
knitr::kable(align = c("l", "r"))
} else {
print("No errors loading sensors.")
}
if (length(pat_list) == 0) {
knitr::knit_exit()
}
empty_test <- purrr::map_lgl(.x = pat_list, .f = function(x) nrow(pat_extractData(x)) > 0)
if(sum(empty_test) < length(empty_test)) {
print("The following Purple Air Time Series loaded, but are empty.")
empty_pats <- names(pat_list)[!empty_test]
print(empty_pats)
print("They are not evaluated in the following report.")
pat_list <- pat_list[empty_test]
}
SoH_functions <- c("PurpleAirSoH_dailyPctReporting"),
SoH_functions <- c("PurpleAirSoH_dailyPctReporting",
"PurpleAirSoH_dailyPctValid",
"PurpleAirSoH_dailyABFit")
purrr::map(pat_list, AirSensor::pat_dailySoH,
SoH_functions = SoH_functions) %>% View()
remove.packages("AirSensor")
devtools::install_github("MazamaScience/AirSensor", ref = "0.5.17")
library(here)
library(dplyr)
library(ggplot2)
library(AirSensor)
devtools::load_all()
library(purrr)
library(formattable)
knitr::opts_knit$set(root.dir = here::here())
# Define problematic cutoffs for looking more closely at site sensors.
MazamaSpatialUtils::setSpatialDataDir("data/spatial")
pat_list <- load_pat_list()
if (params$program != "All") {
sensor_catalog <- load_SensorCatalog() %>%
filter(site != "Undeployed", Program == params$program)
pat_list <- pat_list[sensor_catalog$label]
}
issues_list <- list()
# Checks elements of pat_list whether they are or are not pats.
pat_test <- purrr::map_lgl(.x = pat_list, .f = pat_isPat)
if ( any(!pat_test) ){
# Grab labels of pats that failed to load.
error_list <- pat_list[!pat_test]
# Add to issues list.
issues_list <- error_list
# Filters pat_list according to pat_test
pat_list <- pat_list[pat_test]
}
# Making filter function safe.
safe_pat_filterDate <- purrr::safely(.f = pat_filterDate)
# Safely filters pat_list for past week.
filter_results <- pat_list %>%
purrr::map(safe_pat_filterDate, days = 7) %>%
purrr::transpose()
# Getting pats from results
pat_list_wk <- filter_results$result
# Checks if pats contains data after week filter.
empty_test <- purrr::map_lgl(pat_list, pat_isEmpty)
if ( any(empty_test) ) {
# Get labels of empty pats.
empty_labs <- names(pat_list_wk[empty_test])
empty_list <- list()
for (i in 1:length(empty_labs)) {
empty_lab <- empty_labs[i]
empty_list[empty_lab] <- "Empty"
}
issues_list <- c(issues_list, empty_list)
# Filters out empty data pats.
pat_list_wk <- pat_list_wk[!empty_data_test]
}
# Getting errors.
filter_errors <- filter_results$error %>%
purrr::compact() %>%
purrr::map(.f = function(x) x$message)
# Adding to error list.
issues_list <- c(issues_list, filter_errors)
if ( length(issues_list) >= 1 ) {
# Creating dataframe of sensors that didn't load properly and their error messages.
pat_errors <- reshape::melt(issues_list) %>%
select(`Sensor Label` = 2, Error = 1) %>%
# Cleaning Error Message.
mutate(Error = stringr::str_replace(.data$Error,
pattern = "^.*, :",
replacement = "Error: ")) %>%
mutate(
Error = case_when(
stringr::str_detect(Error,
"pat does not contain requested date range") ~ "Error: sensor has not uploaded data in the past seven days.",
stringr::str_detect(Error, "^Empty$") ~ "Error: Sensor detected by PurpleAir.com but no data loaded.",
# TODO Add more case interpretation.
TRUE ~ paste("Unexpected ", Error)
)
)
pat_errors %>%
knitr::kable(align = c("l", "r"))
} else {
print("No errors loading sensors.")
}
if (length(pat_list) == 0) {
knitr::knit_exit()
}
empty_test <- purrr::map_lgl(.x = pat_list, .f = function(x) nrow(pat_extractData(x)) > 0)
if(sum(empty_test) < length(empty_test)) {
print("The following Purple Air Time Series loaded, but are empty.")
empty_pats <- names(pat_list)[!empty_test]
print(empty_pats)
print("They are not evaluated in the following report.")
pat_list <- pat_list[empty_test]
}
# Define the functions we want pat_dailySoH to run on our sensors.
SoH_functions <- c("PurpleAirSoH_dailyPctReporting",
"PurpleAirSoH_dailyPctValid",
"PurpleAirSoH_dailyABFit")
purrr::map(pat_list, AirSensor::pat_dailySoH,
SoH_functions = SoH_functions) %>% View()
View(pat_list)
SoH_functions <- c("PurpleAirSoH_dailyPctReporting")
purrr::map(pat_list, AirSensor::pat_dailySoH,
SoH_functions = SoH_functions)
View(PurpleAirSoH_dailyPctReporting())
View(PurpleAirSoH_dailyPctReporting)
View(pat_dailySoH)
View(pat_list)
# Define the functions we want pat_dailySoH to run on our sensors.
SoH_functions <- c(#"PurpleAirSoH_dailyPctReporting",
"PurpleAirSoH_dailyPctValid",
"PurpleAirSoH_dailyABFit")
pat <- pat_list[[1]]
MazamaCoreUtils::stopIfNull(pat)
if (!pat_isPat(pat))
if (!pat_isPat(pat))
stop("Parameter 'pat' is not a valid 'pa_timeseries' object.")
if (pat_isEmpty(pat))
stop("Parameter 'pat' has no data.")
SoH_list <- list()
for (SoH_function in SoH_functions) {
result <- try({
FUN <- get(SoH_function)
}, silent = TRUE)
if (!"try-error" %in% class(result)) {
result <- try({
SoH_list[[SoH_function]] <- FUN(pat)
}, silent = TRUE)
}
for (SoH_function in SoH_functions) {
result <- try({
FUN <- get(SoH_function)
}, silent = TRUE)
if (!"try-error" %in% class(result)) {
result <- try({
SoH_list[[SoH_function]] <- FUN(pat)
}, silent = TRUE)
}
if ("try-error" %in% class(result)) {
localTime <- lubridate::with_tz(pat$data$datetime,
tzone = pat$meta$timezone)
hour <- lubridate::hour(localTime)
start <- lubridate::floor_date(localTime[min(which(hour ==
0))], unit = "hour")
end <- lubridate::floor_date(localTime[max(which(hour ==
23))], unit = "hour")
days <- dplyr::tibble(datetime = MazamaCoreUtils::dateSequence(start,
end, timezone = pat$meta$timezone))
SoH_list[[SoH_function]] <- rep_len(as.numeric(NA),
length.out = length(days$datetime))
}
}
View(SoH_list)
SoH_tbl <- dplyr::bind_cols(SoH_list) %>% dplyr::select(unique("datetime"),
contains("pm25"), contains("temperature"), contains("humidity"))
dplyr::bind_cols(SoH_list)
purrr::map(pat_list, AirSensor::pat_dailySoH) %>% View()
remove.packages("AirSensor")
