---
title: "Quality Assurance and Quality Control: Pt. 1 Cleaning"
author: "Ian Ozeroff"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Vignette Title}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---
```{r env setup, include=FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)

library(dplyr)
devtools::load_all(path = "C://Users/iozeroff/Data-Science/ophealthyair")
devtools::load_all(path = "C://Users/iozeroff/Data-Science/R-Projects/AirSensor")

knitr::opts_knit$set(root.dir = here::here())
```


```{r ingestion, include=FALSE}
# Figure out memory saving way to ingest. 
source("scripts/ingest_all.R")
pat_list <- load_pat_list()
sensor_label <- "EW_VonHillern_RM1_"
pat <- pat_list[[sensor_label]]
```


Operation Healthy Air's QAQC process is built using Mazama Science's [AirSensor](https://github.com/MazamaScience/AirSensor) package (see citations), and consists of two processes, data cleaning and data correction. This vignette will describe how we go about the former. 


## Full Time Series


## Aggregated

In addition to a cleaned time series that can have a correction applied, we also want an aggregated time series of descriptive statistics.


Our aggregation process is only applicable to Purple Air PA-II Sensors, that collect two PM channels (i.e. have two plantower sensors). Operation Healthy Air utilizes both PA-I and PA-II sensors, so we describe sensor type in our PA metadata, and filter our time series by device (described in our Sensor Catalogue). As an example, we'll be using our sensor labelled `r print(names(pat_list))`. The following steps are all achieve within the pat_qaqc_agg function. 

First we apply the AirSensor package's Quality Control function. This replaces all values outside of sensor measurement ranges with NA values. These measurement ranges are:

* Particulate Matter 2.5 (PM25): $0-1000Î¼g/m^3$
* Temperature: $40-185$ &deg;F
* Relative Humidity (RH): $0-100$%

```{r pat_qc, results='hide'}
pat <- pat %>% pat_qc(max_humidity = NULL)
```

Next we utilize AirSensor's pat_aggregateOutlierCounts function. This 

1. Applies the Hampel Filter (See [resources/Mazama-Air-Sensor-Vignettes/](outlier_detection.html)) to all of our time series (PM25, Temp, RH), flags outliers, and replaces outliers for our two PM25 channels with the rolling window median. Below displays the results of this process with the red points as our outlier values, and the green as our replacement values. 

```{r outlierPlot, echo=FALSE}
pat %>% pat_outlierPlot()

```

2. Averages our A & B Particulate Matter channels, giving us a single PM25 measurement.
 
3. Downsamples our time series using the mean from every approximately 120 seconds to hourly.
 
For Hampel Filter specs see below:

```{r pat_aggregateOutlierCounts, results='hide'}
pat_agg <- pat %>%
  pat_aggregateOutlierCounts(replace = c("pm25_A", "pm25_B"), 
                                                   period = "1 hour",
                                                   windowSize = 23, thresholdMin = 8)
```

Lastly, we use the AirSensor function PurpleAirQC_hourly_AB_01 to filter our aggregated time series for quality control. This function runs a two-sample t-test on our A and B channel means, essentially conducting a hypothesis test on the probability of randomly observing the difference in the two means (see [resources/Mazama-Air-Sensor-Vignettes/](purpleair_qc.html) for more detail). Thus, a lower p-value indicates a malfunction of some sort in one or both sensors.

This function then marks as NA data that fails to satisfy any one of the following three conditions:

1. A or B channel has fewer than 20 measurements.
2. The  difference in means between channel A and B for the hour in question is above 10, AND the p-value of our two-sample t-test is < 1e-4.
3. The channel average PM25 value is below 100 AND the difference in means between channel A and B for the hour in question is above 20.


```{r quality control filter}
pat_agg <- pat_agg %>% 
  PurpleAirQC_hourly_AB_01(returnAllColumns = TRUE, min_count = 20)
  
print(head(pat_agg))
```

This dataframe is quite wide, so we can select the columns of interest to us.
```{r agg prettification}

pat_agg %>%
  mutate(pm25_outlierCount = pm25_A_outlierCount + pm25_B_outlierCount) %>% 
  select(datetime, pm25, pm25_outlierCount, humidity = humidity_mean, temperature = temperature_mean) %>% 
  head()

```

And we can look at our new Quality Assured and Controlled timeseries.

```{r qaqcd agg plot, echo=FALSE, eval=FALSE}
aqi_palette <- PWFSLSmoke::AQI


pat_agg %>% 
  mutate(
    pm25_max = (pm25_A_max + pm25_B_max) / 2,
    pm25_min = (pm25_A_min + pm25_B_min) / 2,
    # This isn't working.
    aqi_index = case_when(
      pm25 < aqi_palette$breaks_24[[2]] ~ aqi_palette$names[[1]],
      pm25 >= aqi_palette$breaks24[[2]] & pm25 < aqi_palette$breaks_24[[3]] ~ aqi_palette$names[[2]],
      pm25 >= aqi_palette$breaks24[[3]] & pm25 < aqi_palette$breaks_24[[4]] ~ aqi_palette$names[[3]],
      pm25 >= aqi_palette$breaks_24[[4]] & pm25 < aqi_palette$breaks_24[[5]] ~ aqi_palette$names[[4]],
      pm25 >= aqi_palette$breaks_24[[5]] & pm25 < aqi_palette$breaks_24[[6]] ~ aqi_palette$names[[5]],
      pm25 > aqi_palette$breaks_24[[6]] ~ aqi_palette$names[[6]],
      is.na(pm25) ~ NA
           )
         ) %>%
  ggplot(aes(x = datetime, y = pm25)) +
  geom_pointrange(aes(ymin = pm25_min, ymax = pm25_max)) +
  labs(
    x = "Date",
    y = "PM25",
    title = "Purple Air PM25 Hourly Averages",
    subtitle = "with minimum and maximum lines",
    caption = names(pat_list)    
  ) +
  scale_color_manual(values) +
  ggthemes::theme_fivethirtyeight()
```



# Citations
```{r, citations}

citation("AirSensor")


```





